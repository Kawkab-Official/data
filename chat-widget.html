<!doctype html>
<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
<title>Ø¨ÙˆØª ÙƒÙˆÙƒØ¨</title>
<style>
:root{
  --accent:#111;
  --userBg:#d0f0ff;
  --botBg:#fff6c2;
  --card:#fff;
}

html,body{
  height:100%;
  margin:0;
  background:transparent;
  font-family:"Tahoma",system-ui;
}

.chat-box {
  width:100%;
  height:100%;
  max-height:100dvh;
  background:var(--card);
  display:flex;
  flex-direction:column;
  border-radius:12px 12px 0 0;
  overflow:hidden;
  box-shadow:0 10px 30px rgba(2,6,23,0.12);
}

.area{
  flex:1;
  padding:12px;
  overflow-y:auto;
  overflow-x:hidden;
  display:flex;
  flex-direction:column;
  gap:8px;
  min-height:0;
  -webkit-overflow-scrolling:touch;
  scroll-behavior:smooth;
}

.controls{
  padding:10px 12px calc(12px + env(safe-area-inset-bottom,0px));
  border-top:1px solid #eee;
  display:flex;
  flex-direction:column;
  gap:8px;
  flex-shrink:0;
  background:var(--card);
}

.chat-input{
  border:1px solid #ccc;
  border-radius:8px;
  padding:10px;
  font-size:14px;
  resize:none;
  width:100%;
  box-sizing:border-box;
}

button{
  padding:10px;
  background:var(--accent);
  color:#fff;
  border:none;
  border-radius:8px;
  cursor:pointer;
}
</style>
</head>
<body>
<div class="chat-box">
  <div class="area" id="messages">
    <div>ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø¨ÙˆØª ÙƒÙˆÙƒØ¨</div>
  </div>
  <div class="controls">
    <textarea class="chat-input" rows="1" placeholder="Ø§ÙƒØªØ¨ Ø±Ø³Ø§Ù„ØªÙƒ..."></textarea>
    <button>Ø¥Ø±Ø³Ø§Ù„</button>
  </div>
</div>
</body>
</html>

<script>
(function(){
  'use strict';

  // ====== Ø¥Ø¹Ø¯Ø§Ø¯ vh Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ Ù„Ù…Ø´Ø§ÙƒÙ„ Ø´Ø±ÙŠØ· Ø§Ù„Ù…ØªØµÙØ­ Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙˆØ¨Ø§ÙŠÙ„ ======
  function setVh(){
    // use window.innerHeight to account for browser chrome (address bar)
    document.documentElement.style.setProperty('--vh', (window.innerHeight * 0.01) + 'px');
  }
  window.addEventListener('resize', setVh);
  window.addEventListener('orientationchange', function(){ setTimeout(setVh,300); });
  setVh();

  // ===== Ø¹Ù†Ø§ØµØ± Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© =====
  const openBtn = document.getElementById('openChat');
  const overlay = document.getElementById('chatOverlay');
  const closeBtn = document.getElementById('closeChat');
  const area = document.getElementById('area');
  const inp = document.getElementById('inp');
  const btn = document.getElementById('btn');
  const quick = document.getElementById('quickActions');

  // Worker URL - Ø§ØªØ±ÙƒÙ‡ ÙƒÙ…Ø§ ÙƒØ§Ù† Ø£Ùˆ Ø¹Ø¯Ù‘Ù„Ù‡ Ù„Ùˆ Ù„Ø²Ù…
  const WORKER_URL = 'https://kawkab.kawkab-arabia.workers.dev/';

  // Ø­Ø§Ù„Ø© Ø³Ø±ÙŠØ¹Ø©
  let historyMessages = [], chatOpened = false, finalized = false;

  // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ù„Ù„Ø£Ø¨ (parent) Ø¹Ù†Ø¯ Ø§Ù„ÙØªØ­/Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ - Ù„ÙŠØªØ¹Ø§Ù…Ù„ Ø§Ù„Ù€ parent Ù…Ø¹ overflow
  function postToParent(action){
    try{
      if(window.parent && window.parent !== window){
        window.parent.postMessage({action}, '*');
      }
    }catch(e){}
  }

  // Append message Ø«Ù… ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ù€ scrolling Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ (Ù†Ø³ØªØ®Ø¯Ù… scrollIntoView)
  function safeText(s){
    const d = document.createElement('div');
    d.textContent = s;
    return d.innerHTML;
  }

  function append(who, text){
    const w = document.createElement('div');
    w.className = 'msg ' + (who === 'user' ? 'user' : 'bot');
    const b = document.createElement('div');
    b.className = 'bubble';
    b.innerHTML = safeText(text);
    w.appendChild(b);
    const m = document.createElement('div');
    m.className = 'meta';
    // use 24-hour H:M without seconds
    const now = new Date();
    const time = now.toLocaleTimeString('ar-EG', {hour:'2-digit', minute:'2-digit'});
    m.textContent = time;
    w.appendChild(m);
    area.appendChild(w);

    // scroll new message into view safely
    // use requestAnimationFrame to ensure layout updated
    requestAnimationFrame(()=>{
      try{
        // prefer scrollIntoView to avoid messages going out of viewport
        w.scrollIntoView({behavior:'smooth', block:'nearest'});
      }catch(e){
        area.scrollTop = area.scrollHeight - area.clientHeight;
      }
    });
  }

  // show typing indicator element (returns element to remove later)
  function showTyping(){
    const el = document.createElement('div');
    el.className = 'msg bot';
    el.innerHTML = '<div class="bubble"><div class="typing" aria-hidden="true"><span></span><span></span><span></span></div></div>';
    area.appendChild(el);
    // ensure visible
    requestAnimationFrame(()=> el.scrollIntoView({behavior:'smooth', block:'nearest'}));
    return el;
  }

  // auto-scroll when keyboard opens or input focused
  inp.addEventListener('focus', ()=> {
    // small timeout so that mobile keyboard resize finishes
    setTimeout(()=> {
      // scroll last message or area to bottom
      if(area.lastElementChild) area.lastElementChild.scrollIntoView({behavior:'smooth', block:'nearest'});
    }, 300);
  });

  // also monitor viewport changes (mobile keyboard show/hide)
  let lastInnerHeight = window.innerHeight;
  setInterval(()=> {
    if(Math.abs(window.innerHeight - lastInnerHeight) > 120){
      // big change -> probably keyboard open/close -> recalc vh and scroll
      lastInnerHeight = window.innerHeight;
      setVh();
      if(area.lastElementChild) area.lastElementChild.scrollIntoView({behavior:'smooth', block:'nearest'});
    }
  }, 300);

  // init messages when first open
  function openChat(){
    overlay.classList.add('show');
    overlay.setAttribute('aria-hidden', 'false');
    openBtn.classList.add('hidden');
    if(!chatOpened){
      append('bot', 'Ø£Ù‡Ù„Ø§Ù‹ Ø¨ÙŠÙƒ ÙÙŠ Ø¨ÙˆØª ÙƒÙˆÙƒØ¨! Ù‚ÙˆÙ„Ù‘ÙŠ Ø¥Ù†Øª Ø¹Ø§ÙŠØ² ØªÙØ§ÙˆØ¶ Ø¹Ù„Ù‰ Ø¥ÙŠÙ‡ØŸ ğŸ˜');
      chatOpened = true;
    }
    postToParent('chatOpened');
    // focus input after open
    setTimeout(()=> inp.focus(), 400);
  }

  function closeChat(){
    overlay.classList.remove('show');
    overlay.setAttribute('aria-hidden', 'true');
    openBtn.classList.remove('hidden');
    postToParent('chatClosed');
    // return focus to fab
    setTimeout(()=> openBtn.focus(), 200);
  }

  // send payload to worker
  async function sendToWorker(payload){
    try{
      const res = await fetch(WORKER_URL, {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify(payload),
      });
      return res;
    }catch(e){
      throw e;
    }
  }

  // send message flow
  async function sendMessage(){
    const txt = inp.value.trim();
    if(!txt || finalized) return;
    append('user', txt);
    inp.value = '';
    const typing = showTyping();
    btn.disabled = true;
    inp.disabled = true;

    try{
      const res = await sendToWorker({messages: historyMessages.concat([{role:'user', content: txt}])});
      typing.remove();
      if(!res || !res.ok){
        append('bot', 'Ø§Ù„Ù†Øª ÙØ§ØµÙ„ ÙˆÙ„Ø§ ÙÙŠ Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„Ø³ÙŠØ±ÙØ± ğŸ˜…');
      } else {
        const j = await res.json().catch(()=> ({}));
        const reply = j.text || j.reply || 'Ù…Ø´ ÙØ§Ù‡Ù…Ùƒ Ù‚ÙˆÙŠ ğŸ˜… Ø¬Ø±Ø¨ ØªØ§Ù†ÙŠ';
        append('bot', reply);
        historyMessages.push({role:'user', content: txt}, {role:'assistant', content: reply});
      }
    }catch(e){
      try{ typing.remove(); }catch(_){}
      append('bot', 'Ø§Ù„Ù†Øª ÙØ§ØµÙ„ ÙˆÙ„Ø§ Ø¥ÙŠÙ‡ØŸ ğŸ˜…');
    } finally {
      btn.disabled = false;
      inp.disabled = false;
      inp.focus();
    }
  }

  // Events
  openBtn.addEventListener('click', openChat);
  closeBtn.addEventListener('click', closeChat);

  btn.addEventListener('click', sendMessage);
  inp.addEventListener('keydown', (e)=> { if(e.key === 'Enter') sendMessage(); });

  quick.addEventListener('click', (e)=> {
    if(e.target.tagName === 'BUTTON'){
      inp.value = e.target.dataset.text || '';
      inp.focus();
    }
  });

  // ensure that new messages keep visible on DOM changes (MutationObserver)
  const mo = new MutationObserver((mutations)=> {
    // if user is near bottom, keep auto-scrolling
    const threshold = 120;
    const nearBottom = (area.scrollHeight - area.scrollTop - area.clientHeight) < threshold;
    if(nearBottom){
      // scroll last child into view
      const last = area.lastElementChild;
      if(last) last.scrollIntoView({behavior:'smooth', block:'nearest'});
    }
  });
  mo.observe(area, {childList:true, subtree:false});

  // listen to parent messages in case parent decides to force-close or adjust
  window.addEventListener('message', (ev)=> {
    if(!ev.data || typeof ev.data.action !== 'string') return;
    if(ev.data.action === 'closeChat'){
      closeChat();
    }
    // parent could also send focus commands
    if(ev.data.action === 'focusInput'){
      if(overlay.classList.contains('show')) setTimeout(()=> inp.focus(), 200);
    }
  });

  // Accessibility: close on Escape
  window.addEventListener('keydown', (e)=> {
    if(e.key === 'Escape' && overlay.classList.contains('show')){
      closeChat();
    }
  });

  // Prevent accidental page scroll inside iframe when overlay open (best-effort)
  overlay.addEventListener('touchmove', (e)=> {
    // allow internal scrolling but prevent parent scrolling
    e.stopPropagation();
  }, {passive:false});

  // initial small check to ensure area is scrolled to bottom if any preloaded content exists
  setTimeout(()=> {
    if(area.lastElementChild) area.lastElementChild.scrollIntoView({block:'nearest'});
  }, 200);

  // expose a small debug for parent if needed
  window.__KAWKAB_CHAT = {
    open: openChat,
    close: closeChat,
    sendMessageText: (t)=> { inp.value = t; sendMessage(); }
  };

})();
</script>
</body>
</html>
